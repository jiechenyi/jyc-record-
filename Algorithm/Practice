You need to practice over and over again to  achieve handling the questions below just like chewing gums......

二叉树：
二叉树的前序、后序、中序遍历 递归&非递归
由中序 + 另外一种遍历方式 重建二叉树
二叉树层序遍历 换行打印 & z字形打印
二叉树的镜像  递归&非递归
判断二叉树是否为对称的  递归 & 非递归
    ##### 递归 ####
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        return self.ismirror(root,root)
    def ismirror(self,root1,root2):
        if not root1 and not root2:
            return True
        if not root1 or not root2:
            return False
        
        if root1.val == root2.val:
            return self.ismirror(root1.left,root2.right) and self.ismirror(root1.right,root2.left)
        else:
            return False
    ###### 非递归######
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        stack=[root,root]
        while len(stack)>0:
            node1 = stack.pop(0)
            node2=stack.pop(0)
            
            if not node1 and not node2:
                continue
            if not node1 or not node2:
                return False
            if node1.val != node2.val:
                return False
            stack.append(node1.left)
            stack.append(node2.right)
            stack.append(node1.right)
            stack.append(node2.left)
        return True
    
二叉树的最大深度  递归 & 非递归 
### 递归 ####
def maxDepth(root):
	if not root:
		retrun 0
	return max(maxDepth(root.left),maxDepth(root.right))+1
#### 非递归 ###
def maxdepth(root):
	if not root:
		return 0
	stack=[]
	stack.append([1,root])
	res =0
	while len(stack)>0:
		cur,node = stack.pop()
		if node.left:
			stack.append([cur+1,node.left])
		if node.right:
			stack.append([cur+1,node.right])
		res = max(res,cur)
	return res
		
二叉搜索树的最近公共祖先
二叉树的最近公共祖先


DP：
最小编辑距离   dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1)  (word1[i] != word2[j])

背包问题 （0-1 背包、完全背包（物品个数不限）、多背包（物品个数有限个）  
                              dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+c[i])(j>=w[i])
                              dp[i][j] = max(dp[i-1][j],dp[i-1][j-k*w[i]]+k*c[i] ) for k in q[i] 
                              dp[i][j] = max[dp[i-1][j],dp[i][j-w[i]]+c[i])
                              
给定数组不能获取相邻的两个数 ，求和最大  dp[i] = max(dp[i-2]+nums[i],dp[i-1])
最大子序列和（子串和），输出序列？  子序列：dp[i] = max(dp[i-1]+arr[i],dp[i-1],arr[i])
                                 子串：dp[i] = max(dp[i-1]+arr[i],arr[i])
                                 
乘积最大的子序列（子串）  mindp[i] = min(maxdp[i-1]*nums[i],mindp[i-1]*nums[i],nums[i])
                        maxdp[i] = max(mindp[i-1]*nums[i],maxdp[i-1]*nums[i],nums[i])
                        return max(maxdp)
                        
最常上升子序列的长度（子串） 子序列：
				for i in range(1,n):
					for j in range(i,-1,-1):
						if nums[j]<nums[i]:
							dp[i] = max(dp[i],dp[j]+1)
			子串：
				for i in range(1,n):
						if nums[i]>nums[i-1]:
								dp[i] = (dp[i-1]+1,1)

                                              
最长回文子序列（子串） 子序列：dp[i][j] = max(dp[i+1][j-1]+2,dp[i+1][j],dp[i][j-1])
                     子串：dp[i][j] 表示 s[i:j]是不是回文 是的话就标为1 不是的话就标为0				 
			for j in range(n): ####3这个遍历的方式很不一样！！
				for i in range(j-1,-1,-1):
			if j-i+1 == 2 and s[i] == s[j]:
				dp[i][j]=1
			if j-i+1>2:
				if s[i]==s[j]:
						dp[i][j] = dp[i+1][j-1]
				else:
						dp[i][j] = 0

最长公共子序列：	dp[i][j] = dp[i-1][j-1]+1 if word1[i]==word2[j]
		     dp[i][j] = max(dp[i-1][j],dp[i][j-1])
股票每天的价格，只进行一次买入卖出，求最大收益   dp[i] = max(dp[i-1],prices[i]-minp)   minp 表示 前i-1天中的最小的价格
			
0-1 矩阵 求只包含1的最大正方形  dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
0-1矩阵 找出每个元素到最近的0的距离  
数塔问题（三角形 从上往下的最小路径和）  dp[i][j] = min(dp[i-1][j-1],dp[i-1][j])+nums[i][j]  注意边界  也可以用自底向上法 就是遍历要反过来
零钱兑换 （有一个目标值，一个arr ，arr里的coin可以使用任意多
          次，求凑成目标值的方法数）设零钱有n种，目标值为amount  dp：（n）x amount+1）
					dp[i][j] = max(dp[i-1][j],dp[i][j-coins[i-1])  (j>=coins[i])
					dp[i][j] = dp[i-1][j] (j<coins[i])

链表：
找到链表中环的入口  （hash表 / O(1)) 
反转链表
def reverse(head):
	if not head:
		return 
	p = None
	while head:
		q = head.next
		head.next = p
		p = head
		head = q
	return p
两个链表的第一个公共结点
删除链表中的重复元素，使得每个元素只出现一次
    def deleteDuplicates(head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return 
        p = head
        while p:
            if p.next:
                if p.val == p.next.val:
                    if p.next.next:
                        p.next = p.next.next
                    else:
                        p.next = None   
                else:
                    p =p.next
            else:
                p = p.next
        return head
			
			
		
删除重复元素，使其不出现
def delete(head):
	if not head:
		return 
	p = listNond(-99999)
	pre = p
	cur = head
	flag =True
	while cur:
		while cur.next and cur.val == cur.next.val:
			flag = True
			cur= cur.next
		if flag == True:
			pre.next = cur.next
		else:
			pre = cur
		cur = cur.next
	return p.next
		
合并两个有序链表


双/三指针：
三数之和
荷兰国旗问题

排序：
每种的最好最坏情况的复杂度（quick sort and merge sort and heap sort

