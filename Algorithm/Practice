You need to practice over and over again to  achieve handling the questions below just like chewing gums......

二叉树：
是否是平衡二叉树
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        left = self.maxdepth(root.left)
        right = self.maxdepth(root.right)
        if abs(left-right) >1:
            return False
        else:
            return True and self.isBalanced(root.left) and self.isBalanced(root.right)
    def maxdepth(self,root):
        if not root:
            return 0
        return max(self.maxdepth(root.left),self.maxdepth(root.right))+1
	
二叉树的前序、后序、中序遍历 递归&非递归
前序
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        res=[]
        self.help(root,res)
        return res
    def help(self,root,res):
        if not root:
            return []
        res.append(root.val)
        self.help(root.left,res)
        self.help(root.right,res)
#### 非递归 
	def preorderTraversal(self, root):
	"""
	:type root: TreeNode
	:rtype: List[int]
	"""
	if not root:
		return 
	res=[]
	q = []
	node = root
	while len(q)>0 or node:
		while node:
			res.append(node.val)
			q.append(node)
			node = node.left
		node = q.pop()
		node = node.right            
	return res
**中序
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return 
        res=[]
        stack =[]
        
        node = root
        while len(stack)>0 or node:            
            while node:    
                stack.append(node)
                node = node.left
               
            node = stack.pop()
            res.append(node.val)
            node=node.right           
        return res
  **后序
      def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return 
        res =[]
        stack=[]
        node = root
        while len(stack)>0 or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.right
            node = stack.pop()
            node= node.left
        return res[::-1]
		
由中序 + 另外一种遍历方式 重建二叉树
二叉树层序遍历 换行打印 & z字形打印
二叉树的镜像  递归&非递归
### 递归 ###
    def Mirror(self, root):
        # write code here
        if not root:
            return
        tmp = root.left
        root.left = root.right
        root.right = tmp
        self.Mirror(root.left)
        self.Mirror(root.right)
        return root
        
### 非递归###
 def Mirror(self, root):
        # write code here
        if not root:
            return 
        stack =[root]
        while len(stack)>0:
            node = stack.pop()
            if node.left and node.right:
                tmp = node.left
                node.left = node.right
                node.right = tmp
                stack.append(node.left)
                stack.append(node.right)
            elif node.left:
                node.right = node.left
                node.left =None
                stack.append(node.right)
            elif node.right:
                node.left = node.right
                node.right =None
                stack.append(node.left)
        return root
            
判断二叉树是否为对称的  递归 & 非递归
    ##### 递归 ####
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        return self.ismirror(root,root)
    def ismirror(self,root1,root2):
        if not root1 and not root2:
            return True
        if not root1 or not root2:
            return False
        
        if root1.val == root2.val:
            return self.ismirror(root1.left,root2.right) and self.ismirror(root1.right,root2.left)
        else:
            return False
    ###### 非递归######
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        stack=[root,root]
        while len(stack)>0:
            node1 = stack.pop(0)
            node2=stack.pop(0)
            
            if not node1 and not node2:
                continue
            if not node1 or not node2:
                return False
            if node1.val != node2.val:
                return False
            stack.append(node1.left)
            stack.append(node2.right)
            stack.append(node1.right)
            stack.append(node2.left)
        return True
    
二叉树的最大深度  递归 & 非递归 
### 递归 ####
def maxDepth(root):
	if not root:
		retrun 0
	return max(maxDepth(root.left),maxDepth(root.right))+1
#### 非递归 ###
def maxdepth(root):
	if not root:
		return 0
	stack=[]
	stack.append([1,root])   ### 记录层数
	res =0
	while len(stack)>0:
		cur,node = stack.pop()
		if node.left:
			stack.append([cur+1,node.left])
		if node.right:
			stack.append([cur+1,node.right])
		res = max(res,cur)
	return res
		
二叉搜索树的最近公共祖先
##递归##
 def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return 
        if root == p:
            return p
        if root == q:
            return q
        if p.val<root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        if p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root
### 非递归####
    def lowestCommonAncestor(self, root, p, q)：
        if not root:
            return 
        if root == p:
            return p
        if root == q:
            return q
        while root:
            if p.val<root.val and q.val < root.val:
                root = root.left
            elif p.val > root.val and q.val >root.val:
                root = root.right
            else:
                return root
二叉树的最近公共祖先
### 递归 ###
    def lowestCommonAncestor(self, root, p, q):
        if not root or p== root or q==root:
            return root
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if left and right:
            return root
        elif left:
            return left
        elif right:
            return right
            


DP：
最小编辑距离   dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1)  (word1[i] != word2[j])

背包问题 （0-1 背包、完全背包（物品个数不限）、多背包（物品个数有限个）  
                              dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+c[i])(j>=w[i])
                              dp[i][j] = max(dp[i-1][j],dp[i-1][j-k*w[i]]+k*c[i] ) for k in q[i] 
                              dp[i][j] = max[dp[i-1][j],dp[i][j-w[i]]+c[i])
                              
给定数组不能获取相邻的两个数 ，求和最大  dp[i] = max(dp[i-2]+nums[i],dp[i-1])
最大子序列和（子串和），输出序列？  子序列：dp[i] = max(dp[i-1]+arr[i],dp[i-1],arr[i])
                                 子串：dp[i] = max(dp[i-1]+arr[i],arr[i])
                                 
乘积最大的子序列（子串）  mindp[i] = min(maxdp[i-1]*nums[i],mindp[i-1]*nums[i],nums[i])
                        maxdp[i] = max(mindp[i-1]*nums[i],maxdp[i-1]*nums[i],nums[i])
                        return max(maxdp)
                        
最长上升子序列的长度（子串） 子序列：
				for i in range(1,n):
					for j in range(i,-1,-1):
						if nums[j]<nums[i]:
							dp[i] = max(dp[i],dp[j]+1)
			子串：
				for i in range(1,n):
						if nums[i]>nums[i-1]:
								dp[i] = (dp[i-1]+1,1)

                                              
最长回文子序列（子串） 子序列：dp[i][j] = max(dp[i+1][j-1]+2,dp[i+1][j],dp[i][j-1])
                     子串：dp[i][j] 表示 s[i:j]是不是回文 是的话就标为1 不是的话就标为0				 
			for j in range(n): ####这个遍历的方式很不一样！！
				for i in range(j-1,-1,-1):
			if j-i+1 == 2 and s[i] == s[j]:
				dp[i][j]=1
			if j-i+1>2:
				if s[i]==s[j]:
						dp[i][j] = dp[i+1][j-1]
				else:
						dp[i][j] = 0

最长公共子序列：	dp[i][j] = dp[i-1][j-1]+1 if word1[i]==word2[j]
		     dp[i][j] = max(dp[i-1][j],dp[i][j-1])
股票每天的价格，只进行一次买入卖出，求最大收益   dp[i] = max(dp[i-1],prices[i]-minp)   minp 表示 前i-1天中的最小的价格
			
0-1 矩阵 求只包含1的最大正方形  dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
0-1矩阵 找出每个元素到最近的0的距离  
数塔问题（三角形 从上往下的最小路径和）  dp[i][j] = min(dp[i-1][j-1],dp[i-1][j])+nums[i][j]  注意边界  也可以用自底向上法 就是遍历要反过来
零钱兑换 （有一个目标值，一个arr ，arr里的coin可以使用任意多
          次，求凑成目标值的方法数）设零钱有n种，目标值为amount  dp：（n）x amount+1）
		  len(coins)=0 or amount =0 的条件注意一下
			for i in range(1,n):
			    for j in range(1,amount+1):
				if j>=coins[i]:
				    dp[i][j] = dp[i-1][j]+dp[i][j-coins[i-1]]
				else:
					dp[i][j] = dp[i-1][j]					

链表：
两两交换链表中结点 
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return 
        
         
        if  head.next:
            tmp = head.next
            head.next = self.swapPairs(tmp.next)
            tmp.next = head
            return tmp
        else:
            return head

找到链表中环的入口  （hash表 / O(1)) 

    def EntryNodeOfLoop(self, pHead):
        # write code here
        if pHead==None or pHead.next==None or pHead.next.next==None:
            return 
        pre = pHead.next.next
        cur = pHead.next
        while pre != cur:
            if pre.next==None or pre.next.next==None:
                return None
            pre = pre.next.next
            cur = cur.next
        pre = pHead
        while pre!=cur:
            pre = pre.next
            cur = cur.next
            
        return cur
    
反转链表
def reverse(head):
	if not head:
		return 
	p = None
	while head:
		q = head.next
		head.next = p
		p = head
		head = q
	return p
两个链表的第一个公共结点
  ### 双指针 
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        if not headA or not headB:
            return 
        pa = headA
        pb = headB
        
        while pa!=pb:
            if pa:
                pa = pa.next
            else:
                pa = headB
            if pb:
                pb = pb.next
            else:
                pb = headA
        return pa
	
    ### 计算长度法
      def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        
        """
        if not headA or not headB:
            return 
        a = headA
        b = headB
        n = 0
        m = 0
        while a:
            a = a.next
            n = n+1
        while b:
            b = b.next
            m = m+1
        a = headA
        b = headB
        while a or b:
            if a == b:
                return a
            if n ==m:
                a=a.next
                b = b.next
            elif n>m:
                a=a.next
                n -=1
            else:
                b = b.next
                m -=1
        return 

删除链表中的重复元素，使得每个元素只出现一次
    def deleteDuplicates(head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return 
        p = head
        while p:
            if p.next:
                if p.val == p.next.val:
                    if p.next.next:
                        p.next = p.next.next
                    else:
                        p.next = None   
                else:
                    p =p.next
            else:
                p = p.next
        return head
			
			
		
删除重复元素，使其不出现
def delete(head):
	if not head:
		return 
	p = listNond(-99999)
	pre = p
	cur = head
	flag =True
	while cur:
		while cur.next and cur.val == cur.next.val:
			flag = True
			cur= cur.next
		if flag == True:
			pre.next = cur.next
		else:
			pre = cur
		cur = cur.next
	return p.next
		
合并两个有序链表
#### 递归 ###  非递归的话类似于 归并排序的那部分 
    def Merge(self, pHead1, pHead2):
        # write code here
        if not pHead1:
            return pHead2
        if not pHead2:
            return pHead1
        head = ListNode(0)
        if pHead1.val<pHead2.val:
            head = pHead1
            head.next = self.Merge(pHead1.next,pHead2)
        else:
            head = pHead2
            head.next = self.Merge(pHead1,pHead2.next)
        return head
链表的倒数第k个结点
    def FindKthToTail(self, head, k):
        # write code here
        if not head:
            return
        if k==0:
            return 
        low  =head
        fast = head
        i = 0
        while i<k-1:
            if fast.next:
                fast=fast.next
                i = i+1
            else:
                return 
        while fast.next:
            low = low.next
            fast = fast.next
        return low
删除倒数第N个结点
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        
        if not head:
            return 
        
        low = head
        fast = head
        i = 0
        while i<n-1:
            if fast.next:
                fast = fast.next
                i +=1
        if fast.next:
            while fast.next.next:
                fast = fast.next
                low = low.next
            low.next = low.next.next
            return head
        else: ## 说明 fast已经走到最后一个结点了 那就是要删去第一个结点
            return head.next
        


双/三指针：
三数之和
荷兰国旗问题

def f(arr):


    cur = 0
    low = 0
    hi = len(arr)-1
    while cur<= hi:
        if  arr[cur] == 0 and cur == low:
            cur += 1
            low +=1
        elif arr[cur] == 0 and low<cur:
            tmp = arr[cur]
            arr[cur] =arr[low]
            arr[low] = tmp
            low += 1
            cur +=1
        elif arr[cur] ==1 :
            cur +=1
        elif arr[cur] == 2:
            tmp = arr[cur]
            arr[cur] = arr[hi]
            arr[hi] = tmp
            hi -=1
    print(arr)

有效三角形的个数：
    def triangleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 
        n = len(nums)
        nums.sort()     
        res=0
        for i in range(n-1,1,-1):
            k = 0
            j = i-1
            while k<j:
                if nums[k] + nums[j] > nums[i]:
                    res += j-k
                    j = j-1
                else:
                    k +=1
        return res


排序：
每种的最好最坏情况的复杂度（quick sort and merge sort and heap sort

栈：

栈的压入、弹出序列是否合法
    def IsPopOrder(self, pushV, popV):
        # write code here
        tmp=[]
        pop = popV[:]
        for i in pushV:
            tmp.append(i)
            
            if i == pop[0]:
                
                while tmp[-1] == pop[0]:
                    tmp.pop()
                    pop.pop(0)
                    if not tmp and not pop:
                        return True
        if not tmp and not pop:
            return True
        else:
            return False
